\chapter{Testing}
\label{sec:testing}

Django provides extensive support for testing through its \emph{testing
framework} and \emph{test client}, which were leveraged fully in this project.
Continuous Integration is used in the development process to ensure a high
level of software quality.

\section{Django Testing}
\label{sec:testing-django}

Django provides two main tools for thoroughly testing an application: the
testing framework and the test client.

The testing framework acts as a ``runner'', running all appropriate tests when
it is invoked and tracking the success or failure of each.

The test client is a simple HTTP client which can be used programmatically to
test the system from a user's perspective.

These two tools are used in conjunction to provide thorough testing for the
backup system.

\subsection{Testing Framework}
\label{sec:testing-django-framework}

The Django testing framework expands on Python's \verb!unittest! module, which
provides four important concepts \cite{unittest}:

\begin{description}
  \item[Test Fixtures] \hfill \\
      A fixture is the preparation and/or cleanup actions which must be
      prepared before/after running a particular test. This might involve
      creating test databases or files, for example.
  \item[Test Cases] \hfill \\
      A test case is an actual test itself, checking for a system or unit's
      response to a given set of inputs. It is considered as the smallest unit
      of testing, and the \verb!unittest! module provides a \verb!TestCase!
      base class which can be used to create new test cases.
  \item[Test Suites] \hfill \\
      A test suite is an aggregation of tests that should be executed together.
      It can consist of test cases, other test suites, or both.
  \item[Test Runner] \hfill \\
      A test runner is a program which orchestrates the running of the tests
      themselves, and reports the outcome to the user.
\end{description}

The Django testing framework works by providing a subclass of the built-in
Python \verb!TestCase!, adding some Django-specific functionality (such as
checking that a particular template was rendered, or that the HTTP response
contained a specific header).

Because the Django testing framework extends on the functionality provided by
the Python \verb!unittest! module, it can be used to test much more than just
the web interface. In fact, the only code that cannot be effectively tested is
the asynchronous Twisted code.

\subsection{Test Client}
\label{sec:testing-django-client}

The Django test client is a Python class which acts as a dummy web browser,
allowing the interaction with the web application to be tested
programmatically.

This allows the actual functionality of the web interface to be tested---such
as adding, editing and deleting clients---and checking that the database is
left in the correct state afterwards.

\section{Twisted Testing}
\label{sec:testing-twisted}

Similarly to Django, Twisted offers a testing framework which allows unit
testing of the asynchronous networking code. These tests can be run using the
Django test runner, described in section \ref{sec:testing-django-framework}.
Twisted's testing framework is called \emph{Trial}.

\subsection{Trial}
\label{sec:testing-twisted-trial}

Twisted also contains a testing framework which, similarly to Django, leverages
the Python \verb!unittest! module. In the same way, it subclasses the built-in
\verb!TestCase! class, adding functionality specific to the framework.

Namely, Twisted's testing framework---\emph{Trial}---adds the ability for tests
to pass or fail depending on the value returned after a deferred result has
fired. This allows asynchronous code to be tested like any other.

\section{Continuous Integration}
\label{sec:testing-ci}

Continuous Integration is an agile software practice which refers to the
continuous process of applying software quality control \cite{duvall2007}. The
building, testing and deployment phases of the project are automated so that
they can be performed quickly and (usually) automatically.

In this project, the building and testing phases are automated, and are run
every time a new version is pushed to the version control server. If a test
fails, an email is sent to notify the developer responsible for the failing
code.

\subsection{Hudson Continuous Integration Server}
\label{sec:testing-ci-hudson}

Hudson Continuous Integration Server is a continuous integration tool written
in Java. It is designed to integrate with existing version control systems such
as Git or Subversion.

Throughout the development process to ensure that the quality of the software
produced is high, a Hudson server is used to build and test each new version
of the backup system as it is pushed to central Git repository.

\subsection{Unit \& Integration Tests}

Both \emph{unit testing} and \emph{integration testing} are performed using the
Django testing framework.

The tests are separated into categories according to which application is being
tested. The name and purpose of each test is listed below, though the details
are included in the appendix for brevity.

\subsubsection{Catalog}

\begin{table}[H]
    \centering
    \begin{tabular}{ l  p{7cm} }
        \toprule
        Test                        & Purpose
        \\ \midrule
        ItemPathTest                & Test that a newly created \verb!Item!
                                      is given the correct \verb!path!
                                      attribute automatically.
        \\ \\
        ItemLatestVersionTest       & Test that the \verb!latest_version!
                                      attribute of the \verb!Item! is updated
                                      automatically.
        \\ \\
        GetOrCreateItemTest         & Test that the \verb!get_or_create_item!
                                      method works as expected (for retrieving
                                      items from the catalog or creating them
                                      if they don't already exist).
        \\ \\
        ItemCreatedTest             & Test that creating two items with the
                                      same path but different types does not
                                      cause a database error to occur.
        \\ \\
        ResolveOriginalVersionTest  & Test that a chain of restored versions
                                      resolves to the original version
                                      correctly.
        \\ \\
        BrowseRouteTest             & Test that the catalog browsing view
                                      routes the request to the correct item in
                                      the file system (i.e. browsing
                                      a directory or viewing a file).
        \\ \\
        DownloadVersionTest         & Test that the version download view
                                      retrieves the correct version from the
                                      storage subsystem.
        \\ \\
        RestoreVersionTest          & Test that the restore version view
                                      creates a \verb!RestoreJob! object in the
                                      database with the correct parameters to
                                      effect a particular restore.
        \\ \bottomrule
    \end{tabular}
    \caption{Unit and integration tests for the \emph{catalog} application}
    \label{tab:tests-catalog}
\end{table}

\subsubsection{Clients}

\begin{table}[H]
    \centering
    \begin{tabular}{ l  p{7cm} }
        \toprule
        Test                        & Purpose
        \\ \midrule
        CreateClientTest            & Test that the create client view creates
                                      the client correctly.
        \\ \\
        InitialStatusTest           & Test that the client's initial
                                      \verb!Status! object is created
                                      automatically.
        \\ \\
        CreateClientFilePathsTest   & Test that the correct \verb!FilePath!
                                      objects are created with a client
                                      through the web interface.
        \\ \\
        UpdateClientTest            & Test that updating a client's details
                                      modifies the database correctly.
        \\ \\
        DeleteClientTest            & Test that deleting a client removes the
                                      client from the database correctly.

        \\ \\
        ConnectClientTest           & Test that a client is marked as being
                                      connected when the
                                      \verb!client_connected! signal is
                                      dispatched (see section
                                      \ref{sec:implementation-django-signals}).
        \\ \\
        DisconnectClientTest        & Test that a client is marked as being
                                      disconnected when the
                                      \verb!client_disconnected! signal is
                                      dispatched (see section
                                      \ref{sec:implementation-django-signals}).
        \\ \bottomrule
    \end{tabular}
    \caption{Unit and integration tests for the \emph{clients} application}
    \label{tab:tests-clients}
\end{table}

\subsubsection{Core}

\begin{table}[H]
    \centering
    \begin{tabular}{ l  p{7cm} }
        \toprule
        Test                        & Purpose
        \\ \midrule
        GlobalExclusionsTest        & Test that the global exclusions are
                                      correctly added to the database when
                                      they are configured through the web
                                      interface.
        \\ \bottomrule
    \end{tabular}
    \caption{Unit and integration tests for the \emph{core} application}
    \label{tab:tests-core}
\end{table}
