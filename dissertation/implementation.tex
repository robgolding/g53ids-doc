\chapter{Implementation}

This project is implemented in Python, making use of the Django web framework
and the Twisted networking engine.

\section{Python}

\begin{figure}[h]
    \begin{verbatim}
    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity, refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain, it's a bad idea.
    If the implementation is easy to explain, it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!
    \end{verbatim}
    \caption{The Zen of Python, by Tim Peters}
    \label{fig:zen-of-python}
\end{figure}

The backup system is implemented in Python, which is a fast, powerful and
dynamic programming language, suitable for a large variety of application
domains.

Python has a large and feature-rich standard library, and also has many
frameworks and third-party libraries available. Its clean, concise and readable
syntax also make it a pleasant programming language to work with.

Python was created by Guido van Rossum in the early 1990s. To ensure a clear,
easy-to-use language, van Rossum only used ideas that had proven their worth
over time in other programming languages. In particular, he wanted a language
that would be easy to extend for use with other languages.
\cite{lindstrom2005}.

Traditionally, systems of this nature this would most likely be implemented in
a more ``classic'' language such as C or C++. Python offers a modern
alternative to these---not only in syntax but also in mindset.

Python libraries can be written in C, providing low-level access to
the internal Python bindings. This makes Python particluarly suitable for use
with this project, as proof-of-concept code can be written in Python for
ease---and then rewritten in C later if performance is an issue.

\section{Django}

The system implementation is based on top of the Django framework which, though
primarily designed for creating web applications, can be used as the basis for
any type of application.

\begin{quote}
    \emph{Django is a high-level Python Web framework that encourages rapid
    development and clean, pragmatic design.}\footnote{www.djangoproject.com}
\end{quote}

Django is based around a Model-View-Controller (MVC) architecture, separating
the business logic and data functions from the user interface.

In this project, Django is used to provide access to the database (the
\emph{models}) and for the web interface itself.

\subsection{Models}

The models define the persistent data that will be available to the
application, and how that data should be accessed. In Django, this consists of
a series of Python classes, one for each data ``entity'' (see Figure
\ref{fig:erd}).

\begin{singlespacing}
\begin{lstlisting}[caption=The `Event' model, label=lst:event-model]
    class Event(models.Model):
        item = models.ForeignKey(Item, db_index=True)
        occurred_at = models.DateTimeField(auto_now_add=True,
                                           db_index=True)
        type = models.CharField(max_length=20,
                                choices=EVENT_TYPE_CHOICES,
                                db_index=True)

        def __unicode__(self):
            return '%s %s' % (self.get_type_display(),
                              self.item.name)

        class Meta:
            ordering = ['-occurred_at']
            get_latest_by = 'occurred_at'
\end{lstlisting}
\end{singlespacing}

Listing \ref{lst:event-model} shows the definition of the \verb!Event! model,
which has only three attributes: \verb!item! (a foreign key to the \verb!Item!
model), \verb!occured_at! (the date/time at which the event occurred) and
\verb!type! (the type of the event).

The model definition also specifies how an instance of the model should be
displayed if it is printed on screen (the \verb!__unicode__()! method) and how
queries should be ordered (the \verb!Meta! class, defining \verb!ordering!
and \verb!get_latest_by!).

Django provides access to this data through its Object-Relational Mapper (ORM).
This provides a high-level API for querying the database, saving time and
reducing mistakes in the application code. Listing \ref{lst:orm-example} shows
an example of how one might query the database for all \verb!Event!s which
occurred on the \verb!Item! with ID 4, of type ``updated''.

\begin{singlespacing}
\begin{lstlisting}[caption=Querying for all ``updated'' Events on Item 4,
    label=lst:orm-example]
    Item.objects.filter(item__id=4, type='updated')
\end{lstlisting}
\end{singlespacing}

\subsection{Views}

Django uses a slightly different terminology to other popular frameworks, in
that the ``controllers'' (the pieces of code which link together the models and
the user interface) are termed \emph{views}.

The view's purpose is to parse the incoming HTTP request, extract the relevant
data (if any) from the data models, and respond with an appropriate HTTP
response. This is usually constructed by rendering a template.

Fairly obviously, the views are only relevant to the web interface, and are not
used for the core backup system functionality.

\subsection{Templates}

A template (often called a ``view'' in other frameworks) is a file which
defines how the interface will be rendered to the end user. When dealing with
the web, this is usually an HTML file containing variables and simple logic.

Again, the templates are not relevant to the core system functionality---and
only relate to the web interface.

\subsection{Project Structure}

A Django project is separated into multiple ``applications'', each defining its
own models, views, and templates. The idea here is that applications should be
loosely coupled, allowing developers to simply ``plug in'' the desired
functionality by enabling the relevant third-party applications.

This project is separated into three applications: \verb!core!, \verb!clients!,
and \verb!catalog!.

\subsubsection{Core Application}

The core application exists to tie in the functionality provided by the other
two applications, and to provide functionality which does not necessarily
belong in either of them.

The only model defined in the core application is the \verb!GlobalExclusion!,
as it is not directly related to any other model (or the catalog or clients
functionality for that matter).

The core application contains the code for the \emph{dashboard} view, which
provides an overview of the system status and some basic statistics. Also, the
\emph{configuration} view is implemented here---as this is a core system
feature, and not related to the clients or catalog applications.

\subsubsection{Clients Application}

The clients application provides functionality related to the clients
themselves, such as the \verb!Client! model (along with the related
\verb!Status!, \verb!FilePath! and \verb!Exclusion! models) and the views which
allow the administrator to add clients, and edit or delete existing ones.

More detail as to the implementation of the web interface itself is given in
section \ref{sec:impl-web-interface}.

\subsubsection{Catalog Application}

The catalog application provides the main persistent data store for the backup
application (the \emph{catalog}) which records the files and versions that have
been archived from each client. At the core, this consists of the \verb!Item!
and \verb!Version! models. The \verb!Event! and \verb!RestoreJob! models are
also included in the catalog application. See Figure \ref{fig:erd} for the
detailed Entity-Relationship Diagram.

\subsection{Twisted}

Though the backup system is implemented on top of Django, the core
functionality is achieved using the Twisted framework.

Twisted is an open-source event-driven networking engine written in Python. It
allows programmers to write highly asynchronous programs without resorting to
multiple threads or processes, which add to the overall complexity of the
application \cite{kinder2005}.

Due to the asynchronous nature of the framework, programming with Twisted is
different to most other libraries. Central to the framework is the concept of
a \emph{deferred}, which represents an event that is yet to happen. This allows
method calls to return without actually completing their task, and for a given
piece of code to be executed once that task has ended.

At the heart of the Twisted framework is the \emph{reactor}---the main event
loop. This allows the entire application to be ``hooked'' into a central
location, from which all events and callbacks are generated or called.

\subsubsection{Plugins}

Twisted allows developers to create application ``plugins'', which are
networked programs that can be launched using the twisted deamon \emph{twistd}.
This removes the need for complex daemonization routines (the classic
``double-fork'') in the main application code, and eases the management of PID
and log files.

\subsection{pyinotify}

\emph{pyinotify} is an open-source library for Python which provides
a high-level API for the inotify subsystem. It allows the programmer to add
watches to a directory in a recursive manner, and to automatically add watches
to newly created directories below the parent path.

\section{Server}

\subsection{Daemon}

\subsection{Storage}

\section{Client}

\subsection{Queues}

\section{Web Interface}
\label{sec:impl-web-interface}
