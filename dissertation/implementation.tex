\chapter{Implementation}

\section{Django}

The core system implementation is based on the Django framework which, though
primarily designed for creating web applications, can be used as the basis for
any type of application.

\begin{quote}
    \emph{Django is a high-level Python Web framework that encourages rapid
    development and clean, pragmatic design.}\footnote{www.djangoproject.com}
\end{quote}

Django is based around a Model-View-Controller (MVC) architecture, separating
the business logic and data functions from the user interface.

In this project, Django is used to provide access to the database (the
\emph{models}) and for the web interface itself.

\subsection{Models}

The models define the persistent data that will be available to the
application, and how that data should be accessed. In Django, this consists of
a series of Python classes, one for each data ``entity'' (see Figure
\ref{fig:erd}).

\begin{singlespacing}
\begin{lstlisting}[caption=The `Event' model, label=lst:event-model]
    class Event(models.Model):
        item = models.ForeignKey(Item, db_index=True)
        occurred_at = models.DateTimeField(auto_now_add=True,
                                           db_index=True)
        type = models.CharField(max_length=20,
                                choices=EVENT_TYPE_CHOICES,
                                db_index=True)

        def __unicode__(self):
            return '%s %s' % (self.get_type_display(),
                              self.item.name)

        class Meta:
            ordering = ['-occurred_at']
            get_latest_by = 'occurred_at'
\end{lstlisting}
\end{singlespacing}

Listing \ref{lst:event-model} shows the definition of the \verb!Event! model,
which has only three attributes: \verb!item! (a foreign key to the \verb!Item!
model), \verb!occured_at! (the date/time at which the event occurred) and
\verb!type! (the type of the event).

The model definition also specifies how an instance of the model should be
displayed if it is printed on screen (the \verb!__unicode__()! method) and how
queries should be ordered (the \verb!Meta! class, defining \verb!ordering!
and \verb!get_latest_by!).

Django provides access to this data through its Object-Relational Mapper (ORM).
This provides a high-level API for querying the database, saving time and
reducing mistakes in the application code. Listing \ref{lst:orm-example} shows
an example of how one might query the database for all \verb!Event!s which
occurred on the \verb!Item! with ID 4, of type ``updated''.

\begin{singlespacing}
\begin{lstlisting}[caption=Querying for all ``updated'' Events on Item 4,
    label=lst:orm-example]
    Item.objects.filter(item__id=4, type='updated')
\end{lstlisting}
\end{singlespacing}

\subsection{Views}

Django uses a slightly different terminology to other popular frameworks, in
that the ``controllers'' (the pieces of code which link together the models and
the user interface) are termed \emph{views}.

The view's purpose is to parse the incoming HTTP request, extract the relevant
data (if any) from the data models, and respond with an appropriate HTTP
response. This is usually constructed by rendering a template.

Fairly obviously, the views are only relevant to the web interface, and are not
used for the core backup system functionality.

\subsection{Templates}

A template (often called a ``view'' in other frameworks) is a file which
defines how the interface will be rendered to the end user. When dealing with
the web, this is usually an HTML file containing variables and simple logic.

Again, the templates are not relevant to the core system functionality---and
only relate to the web interface.

\subsection{Project Structure}

A Django project is separated into multiple ``applications'', each defining its
own models, views, and templates. The idea here is that applications should be
loosely coupled, allowing developers to simply ``plug in'' the desired
functionality, by enabling the relevant third-party applications.

This project is separated into three applications: \verb!core!, \verb!clients!,
and \verb!catalog!.

\subsubsection{Core Application}

The core application exists to tie in the functionality provided by the other
two applications, and to provide functionality which does not necessarily
belong in either of them.

The only model defined in the core application is the \verb!GlobalExclusion!,
as it is not directly related to any other model (or the catalog or clients
functionality for that matter).

The core application contains the code for the \emph{dashboard} view, which
provides an overview of the system status and some basic statistics. Also, the
\emph{configuration} view is implemented here---as this is a core system
feature, and not related to the clients or catalog applications.

\subsubsection{Clients Application}

The clients application provides functionality related to the clients
themselves, such as the \verb!Client! model (along with the related
\verb!Status!, \verb!FilePath! and \verb!Exclusion! models) and the views which
allow the administrator to add clients, and edit or delete existing ones.

More detail as to the implementation of the web interface itself is given in
section \ref{sec:impl-web-interface}.

\subsubsection{Catalog Application}

The catalog application provides the main persistent data store for the backup
application (the \emph{catalog}) which records the files and versions that have
been archived from each client. At the core, this consists of the \verb!Item!
and \verb!Version! models. The \verb!Event! and \verb!RestoreJob! models are
also included in the catalog application. See Figure \ref{fig:erd} for the
detailed Entity-Relationship Diagram.

\subsection{Twisted}

\subsection{pyinotify}

\section{Server}

\subsection{Daemon}

\subsection{Storage}

\section{Client}

\subsection{Queues}

\section{Web Interface}
\label{sec:impl-web-interface}
