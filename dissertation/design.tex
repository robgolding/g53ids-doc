\chapter{Design}

\section{Architecture}

The architecture of the system is similar to that of the open-source
\emph{Bacula} project, in that it is organised into separate modules. Figure
\ref{fig:architecture} shows the high-level layout of the design, with arrows
to represent the flow of data.

\begin{figure}[h]
    \setlength{\unitlength}{0.14in}
    \centering
    \footnotesize
    \begin{picture}(28,21)
        \put(10,8){\framebox(8,4){backtracserverd}}
        \put(14,8){\vector(0,-1){4}}
        \put(14,4){\vector(0,1){4}}
        \put(10,0){\framebox(8,4){backtracweb}}
        \put(14,16){\vector(0,-1){4}}
        \put(14,12){\vector(0,1){4}}
        \put(10,16){\framebox(8,4){backtracd}}
        \put(18,10){\vector(3,-2){6}}
        \put(24,6){\vector(-3,2){6}}
        \put(24,4){\umlDatabaseLbl{DB}}
        \put(18,2){\vector(3,2){6}}
        \put(24,6){\vector(-3,-2){6}}
        \put(0,4.5){\framebox(6,3){Storage}}
        \put(6,6){\vector(1,1){4}}
        \put(10,10){\vector(-1,-1){4}}
        \put(6,6){\vector(1,-1){4}}
        \put(0,12){\umlRaid}
        \put(3,7.5){\vector(0,1){4.5}}
        \put(3,12){\vector(0,-1){4.5}}
    \end{picture}
    \caption{System architecture diagram}
    \label{fig:architecture}
\end{figure}

At the centre of the system is the server daemon, \emph{backtracserverd}.  It
is this program that maintains a connection to the client daemon,
\emph{backtracd}, which is installed and running on each protected client.

The server daemon also has access to a database, which is used to store not
only the meta-data relating to files protected by the system, but also to the
hosts that it protects. This database is called the \emph{catalog}.

The \emph{storage} subsystem provides an interface for the server daemon to
read and write files to the physical disk, whilst not explicitly choosing their
location or name. This level of abstraction provides extensibility, should
a future implementation change be desired (for example, cloud storage).

The web interface (denoted as \emph{backtracweb} in Figure
\ref{fig:architecture}) allows the administrator to manage and monitor all
aspects of the backup system. The application has read and write access to the
database so clients can be added or altered, and existing clients can be
inspected. Also, read-only access to the storage subsystem is permitted,
allowing the administrator to download files from the archive through the web
interface.

The server daemon and the web interface, though separate programs in their own
right, are intended to run on the same host---the \emph{backup server}.

The database, provided by an RDBMS such as MySQL or PostgreSQL (or SQLite for
smaller installations), can reside on host that is separate to the backup
server. For example, if an existing database server is already installed and
running at a particular site, that server may be used for storing the catalog.

\section{Catalog}

\begin{figure}
    \begin{center}
        \newlength{\svgwidth}
        \setlength{\svgwidth}{1.1\textwidth}
        \tiny
        \input{erd}
    \end{center}
    \caption{Entity-relationship diagram for the catalog}
    \label{fig:erd}
\end{figure}

\subsection{File System Data}

The catalog provides the facility to store meta-data regarding the files that
are backed up. This meta-data includes the size of the file, when it was backed
up, the last modified time of the file, and a hash of the file's contents.

The relational model, depicted in Figure \ref{fig:erd}, allows a tree structure
to be constructed, mirroring the structure of the filesystem on each client.

An \verb!Item! is a file or folder, which has a name and an optional parent
attribute. The parent attribute links an item to it's container (i.e. the
directory it is contained within). If no parent is present, then the item is
located in the root directory of the client

A number of \verb!Version!s can be associated with each \verb!Item!. Each of
these represents a version of the related file on the client, which has been
protected and is stored in the archive. A version has a unique identifier,
which can be used to retrieve the associated file from the storage subsystem.

\subsection{Other Data}

Information relating to the clients themselves is stored in the same database
as the catalog, though it is strictly not considered part of the catalog
itself. A \verb!Client! represents a backup client, which has a hostname and
a secret key with which it authenticates itself to the server.

A separate \verb!Status! object is used to record whether the client is
connected or not, to avoid the user overwriting a status-update whilst
modifying a client through the web interface (as status updates happen whenever
the client connects or disconnects from the server). Each client has one (and
only one) status, so a one-to-one relationship is used here.

Each directory that is to be protected on a client is stored separately in the
database represented by a \verb!FilePath! object. Though it may seem
unnecessary to use an entire object for storing a single attribute, this
ensures that the database is properly normalized.

In the same way, patterns which define files that are to be excluded from the
backup on a given client are stored using \verb!Exclusion! objects.

A \verb!RestoreJob! represents the restoration of a specific version of a file,
to a particular client. It also has attributes to record when the restore was
created, started, and completed. Using these attributes, we can determine
whether the restore is pending, in progress, or completed.

Events relating to the backup file system are also stored in the database,
which are related to a particular \verb!Item!. The \verb!Event! object has
attributes to store when the event occurred, and the type of event
(\verb!created!, \verb!updated!, \verb!deleted! or \verb!restored!). These
event types represent the four distinct operations that can occur on a file
system item.

Finally, a \verb!GlobalExclusion! represents a global exclusion pattern, which
applies to all clients in the system. It is therefore not related to any other
entities in the database.

Figure \ref{fig:erd} shows the entity-relationship diagram for the catalog
database.

\section{Storage}

The storage subsystem provides a purposefully restricted interface for the
server to archive and retrieve files on the filesystem. A file in the storage
subsystem is identified by three attributes:

\begin{itemize}
    \item Bucket name
    \item File name
    \item Version ID
\end{itemize}

To archive a file, only the bucket name and file name must be specified. The
storage subsystem will then generate a unique version ID for the incoming file.
The file will then be written to the archive, in a location which allows it to
be accessed later given these three attributes.

To retrieve a file, the bucket name, file name \emph{and} the version ID must
be specified. The storage subsystem will then retrieve the file, and allow
access to it in a \emph{read-only} manner---as files which have already been
archived should not be modified under any circumstances.

The storage subsystem gives the server code a way of storing files and their
associated versions, without needing to decide (or indeed, record) where on the
filesystem they are located. The server simply needs to record the three
attributes which are used to retrieve a particular file from the archive.

This approach has been chosen as it not only simplifies and abstracts access to
the file system, but also provides a way of structuring the archive, and
keeping that structure intact.

\begin{figure}[H]
    \fbox{\begin{minipage}{\textwidth}
        \vspace{0.5cm}
        \begin{itemize}
                \setlength{\parskip}{0ex}
            \item <Client-1>
                \begin{itemize}
                    \item <File-A>
                        \begin{itemize}
                            \item <Version-1>
                            \item <Version-2>
                        \end{itemize}
                    \item <File-B>
                        \begin{itemize}
                            \item <Version-1>
                        \end{itemize}
                    \item <File-C>
                        \begin{itemize}
                            \item <Version-1>
                            \item <Version-2>
                        \end{itemize}
                \end{itemize}
            \item <Client-2>
                \begin{itemize}
                    \item <File-A>
                        \begin{itemize}
                            \item <Version-1>
                            \item <Version-2>
                        \end{itemize}
                \end{itemize}
            \item <Client-3>
                \begin{itemize}
                    \item <File-A>
                        \begin{itemize}
                            \item <Version-1>
                            \item <Version-2>
                        \end{itemize}
                    \item <File-B>
                        \begin{itemize}
                            \item <Version-1>
                        \end{itemize}
                \end{itemize}
        \end{itemize}
        \vspace{0.1cm}
    \end{minipage}}
    \caption{Storage subsystem archive structure}
    \label{fig:archive-structure}
\end{figure}

The three attributes (bucket name, file name, and version ID) have been chosen
to fit the three pieces of information that are required to identify a file on
a given client in the system---the client's hostname, the file path, and the
version of the file. Figure \ref{fig:archive-structure} shows the structure of
the archive on the file system.

As the figure shows, the top-level directories (buckets) contain all files for
a particular client. Within each bucket, a folder is created for each file on
that client. This folder holds every version of that file, named according to
it's unique ID. This allows a particular version of a file on a specified
client to be retrieved quickly and easily.
